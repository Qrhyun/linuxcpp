/*

#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
    功能：创建一个子进程
    返回值：
        会返回两次
        父进程中返回子进程的pid
        子进程中返回0
        失败在父进程中返回-1
        如何区分父进程和子进程：
            fork返回值为0，说明是子进程
            fork返回值大于0，说明是父进程
            fork返回值小于0，说明创建子进程失败
    注意：
        子进程会复制父进程的数据段、堆、栈等数据，但是子进程的数据是父进程的副本，父子进程之间的数据是独立的
        子进程会复制父进程的文件描述符，但是父子进程之间的文件描述符是独立的
        子进程会复制父进程的信号处理方式，但是父子进程之间的信号是独立的
        子进程会复制父进程的当前工作目录
        子进程会复制父进程的umask
        子进程会复制父进程的资源限制
        子进程会复制父进程的setuid、setgid
        子进程会复制父进程的nice值
        子进程会复制父进程的alarm
        子进程会复制父进程的文件锁
        子进程会复制父进程的信号屏蔽字
        子进程会复制父进程的时钟
        子进程会复制父进程的进程组
        子进程会复制父进程的资源限制
        子进程会复制父进程的进程会话
        子进程会复制父进程的控制终端
        子进程会复制父进程的进程组
        子进程会复制父进程的进程会话
        子进程会复制父进程的控制终端
        子进程会复制父进程的进程组
        子进程会复制父进程的进程会话
    //读时共享，写时复制，父子进程之间的数据是独立的
    //内核中的数据结构是共享的，但是数据即用户区是独立的
*/
#include <unistd.h>
#include <sys/types.h>
#include <stdio.h>

int main() {
    // 创建子进程
    pid_t pid = fork();
    if(pid > 0) {
        // 父进程
        printf("i am parent process, pid : %d\n", getpid());
    } else if(pid == 0){
        // 子进程
        printf("i am child process, pid : %d\n", getpid());
    } else {
        perror("fork");
    }

    for(int i = 0; i < 5; i++) {
        printf("i : %d, pid : %d\n", i, getpid());
    }
    return 0;
} 